<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Alexander Kowsik" />
  <title>Residual Neural Networks</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="css/pandoc.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Residual Neural Networks</h1>
<p class="author">Alexander Kowsik</p>
<p class="date">05.01.2021</p>
</header>
<div id="vid">
<iframe src="https://drive.google.com/file/d/1lWTWhwSrc8Gqd-9N4KbeXVkC3J0RkWnk/preview" height="100%" width="100%">
</iframe>
</div>
<h4 id="momentan-sind-noch-nicht-alle-grafiken-urheberrechtsfrei-auch-sind-einige-der-grafiken-nur-schnell-von-hand-als-idee-erstellt-worden-und-werden-überarbeitet.-das-werde-ich-demnächst-noch-ändern.">Momentan sind noch nicht alle Grafiken urheberrechtsfrei! Auch sind einige der Grafiken nur schnell von Hand als Idee erstellt worden und werden überarbeitet. Das werde ich demnächst noch ändern.</h4>
<h2 id="motivation">Motivation</h2>
<p>Bei <strong>Residual Neural Networks</strong>, oder kurz <em>ResNets</em>, handelt es sich um eine bestimmte Art von neuronalen Netzen, die sich dadurch auszeichnen, dass sie sehr viele hidden layer besitzen, also äußerst ‘tief’ sind. Dabei sind sie trotzdem noch sehr effizient trainierbar und erzielen hohe Performances. Besondere Anwendung finden sie im Bereich der Bildklassifikation in Verbindung mit Convolutional Neural Networks (CNNs).<br />
Bevor wir uns genauer anschauen, wie ResNets aussehen und funktionieren, betrachten wir zunächst das zentrale Problem, welches die Entwicklung von ResNets motiviert hat: das <strong>Trainieren von sehr tiefen Netzen</strong>. “Sehr tief” ist dabei im folgenden alles über ca. 25 hidden layer. Wir schauen uns an, warum das in der Praxis normalerweise nur begrenzt möglich ist und wie ResNets das Problem lösen können.</p>
<h3 id="warum-möchte-man-tiefe-neuronale-netze">Warum möchte man <em>tiefe</em> neuronale Netze?</h3>
<p>Um zu verstehen, warum tiefe Netze oftmals bessere Performance liefern als weniger tiefe Netze, ist es hilfreich, sich noch einmal vor Augen zu führen, wie und warum ein neuronal Netz überhaupt funktioniert, hier mal am Beispiel von <strong>Convolutional Neural Networks</strong>.</p>
<figure>
<img src="images/deepNetVis.png" alt="" /><figcaption>CNNs visualisiert</figcaption>
</figure>
<p>Ein ConvNet besteht in der Regel aus mehrern hintereinander geschalteten convolutional layern mit anschließenden pooling- und batch-normalization layern. Am Ende des Netzwerkes finden sich meistens einige wenige fully-connected layer, die beispielsweise in einem Ausgabe-layer zur Klassifikation enden können. Die Idee für ConvNets entspringt aus den Erkenntnissen aus der klassischen Computergrafik, da die zu lernende Gewichte eines ConvNets die Parameter von linearen Filtern sind, die genutzt werden können, um Strukturen in einem Bild zu erkennen.</p>
<p>Dabei ist es so, dass die gelernten features von Schicht zu Schicht immer abstrakter werden. Man kann es sich so vorstellen, dass die ersten layer lernen, Kanten und Ecken zu erkennen, weitere layer lernen, diese Kanten zu Texturen oder Formen zusammenzusetzen und somit Objektteile zu erkennen, und die letzten Schichten lernen, wie sich diese Objektteile zueinander verhalten und zu ganzen Objekten zusammensetzen. Dadurch wird dann Bilderkennung möglich. In der obigen Abbildung sind die einzelnen Schichten eines ConvNets visualisiert und zeigen diesen Umstand noch einmal eindrücklich, auch wenn es nicht immer der Fall sein muss, dass diese features visuell gut von uns Menschen interpretiert werden können.</p>
<p>Theoretisch ist es möglich, mit nur wenigen layern Klassifikation lediglich anhand der ersten low level features wie den Kanten vorzunehmen, jedoch ist es praktisch nur sehr schwer umzusetzen, da dies extrem viele Trainingsbeispiele und sehr lange Trainingszeit erfordert. Daher ist das Hinzufügen von weiteren layern nur sinnvoll. Es erlaubt es, auf eine effizientere Weise mehr und abstraktere (somit auch bessere) features zu lernen.</p>
<p>Dies ist nicht nur bei Bilderkennung mit ConvNets der Fall. Neuronale Netze sind <strong>universelle Funktionsapproximatoren</strong>. Je mehr layer ein neuronales Netz hat, desto einfacher ist es, immer komplexere Funktionen zu lernen und sich immer mehr der zu lernenden Idealfunktion anzunähern.</p>
<p>Dieser Trend, immer mehr layer zu benutzen um die Performance für eine bestimmte Aufgabe zu steigern, hat sich in der Vergangenheit auch gezeigt.</p>
<figure>
<img src="images/imagenet_competition.jpeg" style="width:80.0%" alt="" /><figcaption>ImageNet competition: Mehr layer = bessere Performance?</figcaption>
</figure>
<p>Betrachtet man die <strong>ImageNet competition</strong> bist zum Jahr 2015, so stellt man fest, dass die Architekturen mit den besten Ergebnissen von Jahr zu Jahr immer tiefer wurden. Auch an anderen Datensätzen war dies erkennbar - tiefere Netze erreichten bessere Genauigkeiten.</p>
<p>Mit diesen Beobachtungen könnte man schlussfolgern, dass tiefe Netze immer besser sind, also die Lösung für schlechte Performance einfach stets “mehr layer” sein könnte. Doch dem ist leider im Allgmeinen nicht so.</p>
<h3 id="das-problem-mit-sehr-tiefen-netzen">Das Problem mit sehr tiefen Netzen</h3>
<p>Es hat sich herausgestellt, dass das Training von sehr tiefen Netzen, also von Netzen mit über ungefähr 25 oder 30 layern, Probleme bereitet und nicht mehr ohne weiteres möglich ist. Warum ist das so?</p>
<figure>
<img src="images/degeneration.jpg" alt="" /><figcaption>Degeneration Problem</figcaption>
</figure>
<p>Der Hauptgrund dafür ist ein Umstand der als <strong>‘degeneration problem’</strong> bekannt ist. Das Hinzufügen von weiteren layern verbessert zwar zunächst die Trainierbarkeit und Performance eines Netzes, letztere erreicht erwartungsgemäß irgendwann ein gewisses Plateau, fängt jedoch ab einem bestimmten Punkt an, stark abzufallen. Das heißt, insbesondere sind bei sehr tiefen Netzen sowohl der Trainings Error als auch der Test Error viel höher als bei gleichen, weniger tiefen Netzen.</p>
<p>Eine Erklärung dafür könnte <strong>Overfitting</strong> ist. Vielleicht ist das Netz ab einem bestimmten Punkt so komplex, dass es anfängt, sich zu stark an den gegebenen Trainingsdatensatz anzupassen, ihn auswendig zu lernen oder sich zu sehr auf Rauschen in den Daten zu konzentrieren, sodass es nicht mehr gut generalisiert. Overfitting kann man hier jedoch ausschließen, da nicht nur der Test Error, sondern auch der Trainings Error höher ist, das Netz also noch nicht einmal die Trainingsdaten gut erfasst. Das bedeutet auch, dass weder Dropout noch andere Regularisierungsmaßnahmen gegen das degeneration problem helfen.</p>
<p>Eine weitere Erklärung ist das Problem von <strong>vanishing und exploding gradients</strong>. Da im backpropagation Schritt die Gradienten der loss Funktion mithilfe die Kettenregel ermittelt werden und somit bei tiefen Netzen sehr viele Terme miteinander multipliziert werden, kann das Ergebnis bei sehr kleinen Zwischenwerten sehr klein (oder 0) und bei großen sehr groß werden, sodass die Konvergenz behindert wird und das Training somit fehlschlägt. Dieses Problem ist tatsächlich manchmal der Grund, warum das degeneration problem auftritt, jedoch lässt sich zeigen, dass selbst durch Nutzung von batch normalization und Ausschließen von vanishing/exploding gradients das degeneration problem in der Praxis trotzdem noch auftritt.</p>
<figure>
<img src="images/AB.png" style="width:65.0%" alt="" /><figcaption>Tiefe Netze -&gt; zumindest die gleiche Performance wie weniger tiefe?</figcaption>
</figure>
<p>Es hat stattdessen viel mehr mit dem <strong>Optimierungsmechanismus</strong> zu tun, und damit, wie das <strong>Netzwerk initialisiert</strong> wird. Theoretisch sollte es nämlich so sein, dass ein tieferes Netz A mit n layern wenigstens genau so gute Ergebnisse erzielt wie ein gleiches, nur weniger tiefes Netz B mit m layern. Dies kann man sich auf folgende Weise klarmachen: das tiefere Netz A könnte in seinen ersten layern das gleiche lernen wie B, somit wären die ersten m layer die gleichen wie bei B. Bei allen folgenden layern könnte A die Identitätsfunktion lernen und würde damit die exakt gleichen Ergebnisse liefern wie B.</p>
<p>Doch ganau hier liegt das Problem - <strong>die Identität zu lernen ist in der Regel nur sehr schwierig</strong>. Bei der Initialisierung werden die Parameter nämlich in der Regel aus einer Gaußverteilung mit Mittelwert 0 gezogen. Das heißt, für einen ‘solver’, also Lösealgorithmus, ist es relativ einfach, die Nullfunktion anzunähern, da die Parameter bereits relativ nahe um die 0 verteilt sind. Es ist für ihn jedoch schwer, die Identität zu lernen, genauer gesagt genauso schwer wie jede andere Funktion.<br />
Ein Beispiel: bei einem linearen Filter wäre die Identitätsfunktion</p>
<figure>
<img src="images/3x3.png" style="width:20.0%" alt="" /><figcaption>Identität bei 3x3 convolutions</figcaption>
</figure>
<p>damit müssen alle 9 Gewichte richtig gelernt werden. Ein solver findet in der gegebenen Trainingszeit und mit den vorhanden Trainingsdaten somit meistens keinen Weg dazu. Somit entstehen durch mehr layer auch solche layer, die der Performance des gesamten Netzes schaden, anstatt sie zu verbessern.</p>
<p>Genau hier setzen die Residual Networks an und bieten eine Lösung für eben dieses Problem.</p>
<h2 id="residual-networks">Residual Networks</h2>
<h3 id="das-lernen-von-residuen">Das Lernen von Residuen</h3>
<p>Die Idee, die ermöglicht, einfacher die Identitätsfunktion zu lernen, ist folgende: anstatt zu hoffen, dass alle paar hintereinander geschaltetete layer eine zugrunde liegende Funktion direkt approximieren, werden bei ResNets in den layern nur die <strong>Residuen</strong> zu der Eingabe in dieses layer explizit gelernt, daher auch der Name <em>Residual Networks</em>. Was genau bedeutet das?</p>
<p>Noch einmal zur Erinnerung: der Begriff <em>Residuum</em> bezeichnet die Abweichung eines Datenpunktes von dem vom Modell geschätzten Wert. Im Beispiel von linearer Reagression im R2 wäre dies der vertikale Abstand eines Punktes zur geschätzten Regressionsgerade.</p>
<p>Betrachten wir uns einige hinterinander geschaltete layer eines feed-foward Netzes. Sei <em>x</em> dabei die Eingabe in diese layer und <em>H(x)</em> die zugrunde liegende Funktion, die von diesen layern gefitted werden soll. Anstatt diese layer direkt <em>H(x)</em> approximieren zu lassen, lernen die layer in ResNets die Restfunktion <strong><em>F(x) = H(x) - x</em></strong>, also lediglich die Abweichung der Eingabe <em>x</em> von der Idealfunktion, umgeschrieben <em>H(x) = x + F(x)</em>. Beide Ansätze approximieren asymptotisch die gewünschte Funktion, jedoch hat sich herausgestellt, dass das Lernen von Residuen einfacher zu sein scheint und eine Reihe Vorteile mit sich bringt.</p>
<figure>
<img src="../images/residuals.png" style="width:70.0%" alt="" /><figcaption>Lernen von Residuen</figcaption>
</figure>
<p>Der Hauptgrund dafür wird ersichtlich, wenn wir uns die Motivation für ResNets noch einmal anschauen. Es ist wie in den obigen Kapiteln beschrieben natürlich wünschenswert, wenn ein tiefes Netz wenigstens genauso gut ist wie ein weniger tiefes, gleich aufgebautes Netz. In der Praxis kommt jedoch das degeneration problem dazwischen, und ein Hauptgrund dafür ist, dass die Identitätsfunktion normalerweise nur schwer gelernt werden kann.</p>
<p>Mit der <strong>Reformulierung des Lernprozesses</strong> zu dem Lernen von Residuen wird dieses Problem nun jedoch gelöst. Wenn die Identitätsfunktion die optimale Funktion für die betrachteten layer ist, kann der solver die Gewichte von <em>F(x)</em> relativ einfach gegen 0 steuern, da sie ohnehin bereits relativ nah um die 0 herum verteilt sind, sodass <em>F(x) = 0</em> wird. Somit wird mit H(x) = 0 + x = x die gewünschte Identitätsfunktion erreicht. Die Eingabe in die layer wird einfach unverändert an hintere layer weitergereicht. Und wenn <em>H(x)</em> nicht die Identiät ist, lernen die layer mit <em>F(x)</em> eben alles nötige “was <em>x</em> noch fehlt” um <em>H(x)</em> zu approximieren.</p>
<p>Doch wie genau wird dies in einem ResNet umgesetzt und wie sieht ein ResNet überhaupt aus?</p>
<h3 id="aufbau-eines-resnets">Aufbau eines ResNets</h3>
<figure>
<img src="../images/resnet_block.png" style="width:65.0%" alt="" /><figcaption>Aufbau eines ResNet-Blocks</figcaption>
</figure>
<p>Ein <strong>ResNet</strong> besteht aus einer Reihe von hintereinander geschalteten <strong>ResNet-Blöcken</strong> (s. Abbildung oben). Ein ResNet-Block umfasst typischerweise zwei bis drei normale hidden layer, das könnten beispielsweise zwei Convolutional layer mit anschließenden pooling und batch normalization layern sein wie im Beispiel unten. Es müssen mindestens zwei sein, da sie sich ansonsten nicht von normalen linearen Netzen unterscheiden würden (s. unten). Das besondere an ResNets sind jedoch die sogenannten ‘shortcut-’ oder <strong>‘skip-connections’</strong>, welche die Eingabe in die layer weiter nach vorne transportieren wo diese zu der Ausgabe aufaddiert werden, in der Regel noch bevor die Aktivierungsfunktion angewandt wird.</p>
<figure>
<img src="../images/1x1.png" style="width:65.0%" alt="" /><figcaption>Beispiel für einen ResNet-Block mit convoltional layern</figcaption>
</figure>
<p>Formal gesehen ist ein ResNet Block <em>y</em> definiert als</p>
<div class="center">
<em>y = F(x, {W<sub>i</sub>}) + W<sub>s</sub>*x</em>,
</div>
<p>wobei <em>F(x ,{W<sub>i</sub>})</em> die von den layern zu lernende Resdiualfunktion parametrisiert mit Gewichten <em>W<sub>i</sub></em> darstellt und <em>x</em> die Eingabe in die layer bezeichnen. Somit approximiert der gesamte Block die Idealfunktion <em>H(x)</em>, also <em>y ~= H(x)</em>.</p>
<p>Da die Dimension der Eingabe nicht unbedingt der Dimension der Ausgabe der layer entsprechen muss, zum Beispiel weil convolutions und pooling angewandt wurden, muss die Eingabe <em>x</em> in diesem Fall auf die Dimension der Ausgabe gebracht werden, dies wird durch die lineare Projektion <em>W<sub>s</sub></em> erreicht. In der Praxis werden dafür oft Padding-Methoden genutzt, jedoch haben sich <strong>1x1 convolutions</strong> als gängige Methode durchgesetzt.</p>
<p>Ansonsten besitzen die skip-connections bei klassischen ResNets keine weiteren Parameter die gelernt werden müssten, sodass durch Setzen der Gewichte <em>Wi</em> auf 0 der Block tatsächlich die Identitätsfunktion nähert.</p>
<figure>
<img src="../images/vgg_resnets.png" style="height:65.0%" alt="" /><figcaption>VGG-19 vs ResNet-152</figcaption>
</figure>
<p>Hier mal das durch das Original-Paper bekannt gewordene <strong>152-layer ResNet</strong> im Vergleich zum prominenten VGG-19 Netz. Die gestrichelten skip-connections im rechten Bild kennzeichnen dabei 1x1 convolutions zur Anpassung der Dimensionen.</p>
<h3 id="performances-von-resnets">Performances von ResNets</h3>
<figure>
<img src="../images/performance.png" alt="" /><figcaption>Performance von ResNet (original paper)</figcaption>
</figure>
<p>Und tatsächlich sind sehr tiefe ResNets ziemlich effizient trainierbar und erzielen gute Resultate. Wie in der obigen Abbildung zu erkennen scheinen ResNets nicht vom degeneration problem betroffen zu sein. Das Hinzufügen von mehr layern führt tatsächlich zu einem <strong>niedrigeren Fehler und besserer Performance</strong>, sowohl auf den Trainings- als auch auf den Testdaten. Tiefe ResNets scheinen mindestens genauso gut und besser zu sein wie weniger tiefe, alle zusätzlichen layer nutzen scheinbar ihr Potential, die Performance zu verbessern.</p>
<p>Wie in Abbildung X zu erkannen, gewannen ResNets mit dem berühmten ResNet-152 die <strong>ImageNet comepetition</strong> im Jahre 2015 mit einem Fehler von nur 3.57% und lösten damit das bis daher beste GoogLeNet mit einem Fehler von 6.7% und 22 layern deutlich ab. Interessanterweise hatte das ResNet-152 viel weniger Parameter als die anderen Wettbewerber und somit auch schneller trainierbar, war jedoch mit 152 layern sehr viel tiefer. Mehr dazu findet sich im übernächsten Kapitel zum Training von ResNets.</p>
<p>Seit dem konnten Architekturen von <strong>über 1000 layern</strong> erfolgreich trainiert werden, und im sehr theoretischen Umfeld auch Netze mit 2000+ layern, sie werden in der Praxis jedoch nicht wirklich eingesetzt, da sie viel zu unnpraktikabel sind. Denn auch ResNets haben ihre Grenzen. Ab einem bestimmten Punkt läuft man nämlich auch Gefahr, die Trainingsdaten zu overfitten, sodass die Performance auch bei ResNets irgendwann abnimmt und mehr layer nicht mehr nützlich, sondern eher schädlich werden.</p>
<h3 id="warum-genau-funktioniert-das-nochmal">Warum genau funktioniert das nochmal?</h3>
<p>Zum einen sind die guten Performances von ResNets auf den Umstand zurückzuführen, dass das <strong>Lernen von Residuen</strong> scheinbar grundsätzlich einfacher zu sein scheint, als das direkte Approximieren einer Zielfunktion. Damit lassen sich auch sehr viel einfacher <strong>Identitätsfunktionen</strong> lernen, sodass es einem größeren Netz die Möglichkeit gibt, wenigstens genauso gut zu sein wie ein gleiches kleineres. Layer, die der Performance nur schaden, können einfach übersprungen werden, indem die Eingabe in diese layer unverändert an hintere layer weitergereicht wird. Dies geschieht auch ganz natürlich und dynamisch durch backpropagation, man braucht keinen zusätzlichen Hyperparameter für die Anzahl der layer hinzuzufügen.</p>
<p>Dadurch, dass gewisse layer einfach übersprungen werden könnten, ähnelt das Training von ResNets dem <strong>Training eines ensembles</strong>. Es erlaubt es, unterschiedliche Teile des Netzwerks zu unterschiedlichen Zeiten und Raten zu trainieren, abhängig davon, wie der Error im Netz zurückpropagiert wird. Somit können durch bestimmte Trainingsbeispiele auf natürliche Weise gezielt Teile des Netztes trainiert werden.</p>
<p>Da nur Residuen gelernt werden, geschieht im Prinzip nur ein <strong>fine-tuning des Input</strong> in einen ResNet Block. Er wird von jedem layer nur ein Stück weit angepasst, um näher an die zu lernende Idealfunktion zu kommen. Die erwartete Ausgabe muss somit nicht ‘von scratch’ generiert werden. Dies erklärt auch, warum das Hinzufügen von layern die Performance noch weiter erhöht - der Input wird mit jedem layer immer noch ein ganz kleines Stück verbessert, zumindest solange, bis man an Overfitting stößt.</p>
<h3 id="training-von-resnets">Training von ResNets</h3>
<ul>
<li>vorteile: viel weniger Parameter = schnelleres end-to-end training mit normalen Verfahren ohne dass man etwas ändern muss</li>
<li>im Prinzip sind die skip connections die einzige große Änderung</li>
<li>forward propagation</li>
</ul>
<p><img src="../images/forward_prop1.png" style="width:65.0%" /></p>
<p><img src="../images/forward_prop2.png" style="width:30.0%" /></p>
<ul>
<li>backpropagation</li>
</ul>
<p><img src="../images/back_prop.png" style="width:65.0%" /></p>
<ul>
<li>training + beispiele?</li>
</ul>
<h3 id="varianten-und-architekturen-implementierung">Varianten und Architekturen + Implementierung</h3>
<ul>
<li>wann welche layer, activation functions, bn etc</li>
<li>andere Architekturen (HighwayNets, DenseNets, ResNext)</li>
</ul>
<!-- HTML generated using hilite.me -->
<div style="background: #f0f0f0; overflow:auto;width:auto;font-size:0.9em;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
<table>
<tr>
<td>
<pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre>
</td>
<td>
<pre style="margin: 0; line-height: 125%"><span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">ResidualBlock</span>(nn<span style="color: #666666">.</span>Module):
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__init__</span>(<span style="color: #007020">self</span>, in_channels, out_channels):
        <span style="color: #007020">super</span>()<span style="color: #666666">.</span>__init__()
        <span style="color: #007020">self</span><span style="color: #666666">.</span>in_channels, <span style="color: #007020">self</span><span style="color: #666666">.</span>out_channels <span style="color: #666666">=</span>  in_channels, out_channels
        <span style="color: #007020">self</span><span style="color: #666666">.</span>blocks <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Identity()
        <span style="color: #007020">self</span><span style="color: #666666">.</span>shortcut <span style="color: #666666">=</span> nn<span style="color: #666666">.</span>Identity()

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">forward</span>(<span style="color: #007020">self</span>, x):
        residual <span style="color: #666666">=</span> x
        <span style="color: #007020; font-weight: bold">if</span> <span style="color: #007020">self</span><span style="color: #666666">.</span>should_apply_shortcut: residual <span style="color: #666666">=</span> <span style="color: #007020">self</span><span style="color: #666666">.</span>shortcut(x)
        x <span style="color: #666666">=</span> <span style="color: #007020">self</span><span style="color: #666666">.</span>blocks(x)
        x <span style="color: #666666">+=</span> residual
        <span style="color: #007020; font-weight: bold">return</span> x

    <span style="color: #555555; font-weight: bold">@property</span>
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">should_apply_shortcut</span>(<span style="color: #007020">self</span>):
        <span style="color: #007020; font-weight: bold">return</span> <span style="color: #007020">self</span><span style="color: #666666">.</span>in_channels <span style="color: #666666">!=</span> <span style="color: #007020">self</span><span style="color: #666666">.</span>out_channels
</pre>
</td>
</tr>
</table>
</div>
<h2 id="zusammenfassung-und-weiterführendes">Zusammenfassung und Weiterführendes</h2>
<ul>
<li>Zusammenfassung</li>
<li>warum nicht überall genutzt?</li>
<li>nochmal kurz Vorteile + Nachteile</li>
<li>Anwendungsgebiete</li>
<li>Abschluss <br><br><br> <br><br><br></li>
</ul>
</body>
</html>
